Description :
-------------

mXS is a basically a general software to automatically annotate segments in sequences when a training corpus is provided. In practice, it is here available as a French NER tagger.

It is currently working out of the box for French, but has been also successfully been tested for English (near state of the art performances) and German (still some work needed to improve performance). Please send an email if you wish support for these languages or intend to train for another language.

Tagging French NEs using ETAPE model for lazy people:
-----------------------------------------------------

Install Treetagger on your machine and set configure its path (comment out and set the TREETAGGER_PATH variable) in:
- bin/conf_machineExample.sh

Using command line, go into mxs root directory, and try (you'll have to wait a minute for lexicons to be loaded):
$ echo "Le président Barack Obama a été à Dakar, au Sénégal, en juin 2013." | ./bin/tagEtapeModel.sh

This command should output the folllowing full annotation, with components:
Le <func.ind> <kind> président </kind> </func.ind> <pers.ind> <name.first> Barack </name.first> <name.last> Obama </name.last> </pers.ind> a été à <loc.adm.town> <name> Dakar </name> </loc.adm.town> , au <loc.adm.nat> <name> Sénégal </name> </loc.adm.nat> , en juin 2013 .

In case you only need PERS, LOC, ORG, FUNC without components, a simpler and much faster model (after loading lexicons) is available:
$  echo "Le président Barack Obama a été à Dakar, au Sénégal, en juin 2013." | ./bin/tagEtapeModelPLOP.sh

Which will output annotations according to a basic scheme:
Le <func> président </func> <pers> Barack Obama </pers> a été à <loc> Dakar </loc> , au <loc> Sénégal </loc> , en juin 2013 .

(Very) Short how-to :
---------------------

This is an alpha release and I advise to contact me for installation / configuration / usage. My current problems are the availability of corpora for French, and adaptations of preprocessings (TreeTagger) for English. Anyway, let's write a very quick start guide.

This software requires:
- TreeTagger : http://www.cis.uni-muenchen.de/~schmid/tools/TreeTagger
- scikit-learn : http://scikit-learn.org/stable/

You may want to only tag texts. In that case, provide the correct path for TreeTagger in:
- bin/conf_machineExample.sh

Source this file and the the configuration for the NER model (learned for French over Etape corpus http://www.afcp-parole.org/etape.html):
$ . ./bin/conf_machineExample.sh
$ . ./bin/conf_EtapeModel.sh

Try to tag a text (be patient, loading models may take a few minutes), e.g.:
$ echo "Le président Barack Obama a été en Afrique du Sud le 30 juillet 2013." | ./bin/tagSciKit.sh

For learning models over a specific corpus (and testing it), you'll need more configuration... first, compile the pattern extractor:
$ make clean && make

Adapt configuration directives in:
- bin/conf_DatasetExample.sh

As previously, source configuration files:
$ . ./bin/conf_machineExample.sh
$ . ./bin/conf_DatasetExample.sh

Then try the whole process:
$ ./bin/testCorpus.sh

Hopefully, the script testCorpus.sh is human-readable. In a few words, it should:
1 Pre-process corpora
2 Extract patterns from train corpus
3 Learn regression models using scikit-learn
4 Use models to tag test corpus

Ok, this is very minimal. Much more to come, sooner or later, dependending on requests, with an examplified dataset...

Pattern extractor:
------------------

sminer extracts all sequences having a frequency greater than or equal to a minimum threshhold. Target (objective) items may be searched according to a confidence threshold and outputed (as "annotation rules").

Items may be form a hierarchy (subs) : then specialisation is indicated using "/" operator (e.g. A/B and A/C are two items in data, and both are subtypes of A). The hierarchy may be a forest. Take care not to mix targets and none targets within same tree.

Patterns of identical frequencies which are generalization one of each other are grouped together, and only maximal (or minimal) patterns are to be extracted.
